#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define KEY_LEN 64
#define MEAN_LEN 256

typedef struct Node {
    char key[KEY_LEN];
    char meaning[MEAN_LEN];
    struct Node *left, *right;
} Node;

Node* createNode(const char *key, const char *meaning){
    Node *n = (Node*)malloc(sizeof(Node));
    if(!n){ perror("malloc"); exit(1); }
    strncpy(n->key, key, KEY_LEN-1); n->key[KEY_LEN-1]=0;
    strncpy(n->meaning, meaning, MEAN_LEN-1); n->meaning[MEAN_LEN-1]=0;
    n->left = n->right = NULL;
    return n;
}

Node* insertBST(Node *root, const char *key, const char *meaning){
    if(!root) return createNode(key, meaning);
    int cmp = strcmp(key, root->key);
    if(cmp < 0) root->left = insertBST(root->left, key, meaning);
    else if(cmp > 0) root->right = insertBST(root->right, key, meaning);
    else printf("Keyword '%s' exists. Use update.\n", key);
    return root;
}

Node* findMinNode(Node *root){ if(!root) return NULL; while(root->left) root=root->left; return root; }

Node* deleteBST(Node *root, const char *key){
    if(!root){ printf("Keyword '%s' not found.\n", key); return NULL; }
    int cmp = strcmp(key, root->key);
    if(cmp < 0) root->left = deleteBST(root->left, key);
    else if(cmp > 0) root->right = deleteBST(root->right, key);
    else {
        if(!root->left && !root->right){ free(root); return NULL; }
        else if(!root->left){ Node *r = root->right; free(root); return r; }
        else if(!root->right){ Node *l = root->left; free(root); return l; }
        else {
            Node *minR = findMinNode(root->right);
            strncpy(root->key, minR->key, KEY_LEN);
            strncpy(root->meaning, minR->meaning, MEAN_LEN);
            root->right = deleteBST(root->right, minR->key);
        }
    }
    return root;
}

int updateMeaning(Node *root, const char *key, const char *newMeaning){
    if(!root) return 0;
    int cmp = strcmp(key, root->key);
    if(cmp == 0){ strncpy(root->meaning, newMeaning, MEAN_LEN-1); root->meaning[MEAN_LEN-1]=0; return 1; }
    else if(cmp < 0) return updateMeaning(root->left, key, newMeaning);
    else return updateMeaning(root->right, key, newMeaning);
}

void inorder(Node *root){ if(!root) return; inorder(root->left); printf("Keyword : %s\nMeaning : %s\n-------------------------\n", root->key, root->meaning); inorder(root->right); }
void reverseInorder(Node *root){ if(!root) return; reverseInorder(root->right); printf("Keyword : %s\nMeaning : %s\n-------------------------\n", root->key, root->meaning); reverseInorder(root->left); }

int height_nodes(Node *root){ if(!root) return 0; int lh = height_nodes(root->left), rh = height_nodes(root->right); return (lh>rh?lh:rh)+1; }

Node* searchBST(Node *root, const char *key){ if(!root) return NULL; int cmp = strcmp(key, root->key); if(cmp==0) return root; else if(cmp<0) return searchBST(root->left, key); else return searchBST(root->right, key); }

void freeTree(Node *root){ if(!root) return; freeTree(root->left); freeTree(root->right); free(root); }

void readLine(char *buf, int size){ if(!fgets(buf, size, stdin)) buf[0]=0; buf[strcspn(buf, "\n")]=0; }

int main(){
    Node *root = NULL;
    int choice;
    char key[KEY_LEN], meaning[MEAN_LEN];

    while(1){
        printf("\n--- Dictionary (BST) ---\n1.Add keyword\n2.Delete keyword\n3.Update meaning\n4.Display Ascending\n5.Display Descending\n6.Max comparisons (worst-case)\n7.Search keyword\n8.Exit\nEnter choice: ");
        if(scanf("%d",&choice)!=1) break;
        getchar();
        switch(choice){
            case 1:
                printf("Enter keyword: "); readLine(key, KEY_LEN);
                printf("Enter meaning: "); readLine(meaning, MEAN_LEN);
                root = insertBST(root, key, meaning);
                break;
            case 2:
                printf("Enter keyword to delete: "); readLine(key, KEY_LEN);
                root = deleteBST(root, key);
                break;
            case 3:
                printf("Enter keyword to update: "); readLine(key, KEY_LEN);
                printf("Enter new meaning: "); readLine(meaning, MEAN_LEN);
                if(updateMeaning(root, key, meaning)) printf("Updated.\n"); else printf("Not found.\n");
                break;
            case 4:
                printf("\n--- Ascending ---\n"); inorder(root); break;
            case 5:
                printf("\n--- Descending ---\n"); reverseInorder(root); break;
            case 6: {
                int h = height_nodes(root);
                if(h==0) printf("Dictionary empty.\n"); else printf("Max comparisons (worst-case) = %d\n", h);
                break;
            }
            case 7:
                printf("Enter keyword to search: "); readLine(key, KEY_LEN);
                {
                    Node *p = searchBST(root, key);
                    if(p) printf("Found:\nKeyword: %s\nMeaning: %s\n", p->key, p->meaning);
                    else printf("Not found.\n");
                }
                break;
            case 8:
                freeTree(root); printf("Exiting.\n"); return 0;
            default:
                printf("Invalid choice.\n");
        }
    }

    freeTree(root);
    return 0;
}
